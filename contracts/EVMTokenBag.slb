pragma solidity ^0.5.2;
pragma experimental ABIEncoderV2;


library EVMTokenBag {

    uint8 constant internal ERC20TYPE = 0;
    uint8 constant internal ERC721TYPE = 1;
    uint8 constant internal ERC1948TYPE = 2;
  
    struct Output {
        address owner;
        uint valueOrId;
        bytes32 data;
        address color;
        uint8 tokenType;
    }
  
    struct TokenBag {
        Output[16] bag;
    }
    
    function balanceOf(
        TokenBag memory self,
        address color,
        address owner
    ) internal pure returns (uint value) {
        Output memory output;
        for (uint i = 0; i < self.bag.length; i++) {
            output = self.bag[i];
            if (output.owner == owner && output.color == color) {
      	         value = output.valueOrId;
      	         break;
            }
        }
    }
    
    function readData(
        TokenBag memory self,
        address color,
        uint id
    ) internal pure returns (bytes32 data) {
        Output memory output;
        for (uint i = 0; i < self.bag.length; i++) {
            output = self.bag[i];
            if (output.valueOrId == id && output.color == color) {
                data = output.data;
                break;
            }
        }
    }

    function transferFrom(
                          TokenBag memory self,
                          address color,
                          address from,
                          address to,
                          uint valueOrId
                          ) internal pure returns (bool) {
      if (to == address(0)) return false;
      (Output memory source, bool success) = findToken(self, color, from);
      // sender's token/tokens don't exist
      if (!success) return false;
      if (source.tokenType == ERC20TYPE) {
        Output memory dest;
        (dest, success) = findToken(self, color, to);
        if (!success) {
          (dest, success) = findToken(self, address(0), address(0));
        }
        // no slot found for output token
        if (!success) return false;
        // sender does not have enough tokens to send and/or underflow
        if (source.valueOrId < valueOrId) return false;
        // overflow
        if (valueOrId + dest.valueOrId < valueOrId) return false;

        dest.owner = to;
        dest.color = color;
        dest.valueOrId += valueOrId;
        source.valueOrId -= valueOrId;

        return true;
      } else if (source.tokenType == ERC721TYPE) {
        
      } else if (source.tokenType == ERC1948TYPE) {
        
      }
    }

    function findToken(
                       TokenBag memory self,
                       address color,
                       address owner
                       ) internal pure returns (Output memory, bool) {
      Output memory token;
      bool success;
      for (uint i = 0; i < self.bag.length; i++) {
          if (self.bag[i].owner == owner && self.bag[i].color == color) {
              token = self.bag[i];
              success = true;
              break;
          }
      }
      return (token, success);
    }
                     
      

}
